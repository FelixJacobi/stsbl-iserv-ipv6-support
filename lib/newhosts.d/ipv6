#!/usr/bin/perl -CSDAL

use warnings; 
use strict;
use File::Slurp::Unicode;
use IServ::DB;
use NetAddr::MAC;
use Time::HiRes qw(gettimeofday tv_interval);

my @prefixes = sort split "\n", qx(netquery6 --lan --global --format "nic prefix");

sub print_time($$)
{
  my ($mod, $time) = @_;
  printf "$mod: %.0fms\n", tv_interval($time) * 1000;
}

# update MAC check rules
{
  my %rules;
  my $moduletime = [gettimeofday];

  # create a list of rules that should exist according to the database
  for my $row (IServ::DB::SelectAll("SELECT mac FROM hosts ".
      "WHERE mac IS NOT NULL"))
  {
    my $mac = new NetAddr::MAC $row->{mac};

    for my $prefix (@prefixes)
    {
      my ($nic, $net) = split " ", $prefix;

      # strip double : at end
      $net =~ s/:$//;
 
      my $ip = $net . as_ipv6_suffix $mac;
      $rules{"-A check_mac -s $ip ! -i $nic -m mac ! --mac-source $row->{mac} ".
        "-j REJECT --reject-with icmp6-port-unreachable"}++;
    }
  }

  # compare this list with the current state according to iptables-save
  open my $fp, "-|", "ip6tables-save", "-t", "filter" or die $!;
  while (<$fp>)
  {
    s/\s+$//;
    s/\/32\b//;
    # convert MAC addresses to lowercase; a database constraint ensures that
    # the MAC addresses we get from the query are already lowercase
    s/--mac-source \K((?:[0-9a-f]{2}:){5}[0-9a-f]{2})\b/\L$1\E/gi;
    if (exists $rules{$_})
    {
      # the rule already exists
      delete $rules{$_};
    }
    elsif (s/^-A(?= check_mac\b)/-D/)
    {
      # a stale rule exists that has to be removed
      $rules{$_}++;
    }
  }
  close $fp;

  # apply changes
  if (%rules)
  {
    printf "updating ip6tables (%d rules)...\n", scalar keys %rules;
    open my $fp, "|-", "ip6tables-restore", "-n" or die $!;
    print $fp "*filter\n";
    print $fp map "$_\n", keys %rules;
    print $fp "COMMIT\n";
    close $fp;
  }

  print_time("update mac checks", $moduletime);
}

# dhcp
{
  my $out;
  my %networks;
  my $moduletime = [gettimeofday];

  for (@{ DBH->selectall_arrayref("SELECT Name, MAC ".
    "FROM hosts WHERE MAC IS NOT NULL ORDER BY Name") or die $! })
  {
    my ($name, $mac) = @$_;

    for my $prefix (sort @prefixes)
    {
      my ($nic, $net) = split " ", $prefix;

      # strip double : at end
      my $ip_net = substr $net, 0, -2;
      my $mac_converter = new NetAddr::MAC $mac;
      my $ip = $ip_net . ":" . as_ipv6_suffix $mac_converter;

      my @content;
      undef @content;
      @content = @{ $out->{$nic} } if defined $out->{$nic};
      @content = () if not @content;

      push @content, "    host $name-$nic {\n";
      push @content, "      hardware ethernet $mac;\n";
      push @content, "      fixed-address6 $ip;\n";
      push @content, "    }\n";

      $out->{$nic} = \@content;
      $networks{$nic} = $net;
    }
  }

  my @write;

  for my $nic (sort keys %$out)
  {
    push @write, "shared-network $nic {\n";
    push @write, "  subnet6 $networks{$nic}/64 {\n";
    push @write, @{ $out->{$nic} };
    push @write, "  }\n";
    push @write, "}\n"
  }

  write_file "/var/lib/iserv/config/dhcpd6.conf.hosts", @write;
  system "/etc/init.d/isc-dhcp-server6", "restart", "&>/dev/null", "&";
  print_time("update dhcp", $moduletime);
}
